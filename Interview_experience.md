## <center>面试经验总结</center>

### 大型企业渗透测试个人去做怎么做

- 在非授权下，第一步应该隐藏自己。授权例外，然后进行信息搜集、扫描、入侵、内网渗透
    - 信息收集：`whoami`域名反查，域名注册人信息查询，搜索引擎搜索公司相关负责人（`google hacking`），子域名收集
    - 扫描：Nmap扫描端口，C段扫描
    - 入侵：SQL注入，弱口令，XSS，文件上传
    - 内网渗透：传马，提权，流量转发，内网扫描等

### 安全模式下绕过PHP的disable function

- DL函数，组件漏洞，环境变量
    - DL函数：在正式的生成环境中，为了更安全地运行PHP，也可以使用`disable_functions`指令来禁止一些敏感函数的使用。当你想用本指令禁止一些危险函数时，切记要把DL()函数也加到禁止列表，因为攻击者可以利用dl()函数来加载自定义的PHP扩展以突破`disable_functions`指令的限制
    - 组件漏洞
    - 环境变量

### SQL注入头注入点

- `UA`
- `REFERER`
- `COOKIE`
- `IP`

### PHP中命令执行设计到的函数

- eval()、assert()、popen()、system()、exec()、shell_exec()、passthru()、pcntl_exec()等函数反引号，花括号嵌套
- 文件包含可能导致命令执行
- 正则表达式`e/`修饰
- `creat_function`

### 金融行业常见逻辑漏洞

- 单针对金融和业务的漏洞，除了通用性漏洞以外，主要是数据的篡改（设计金融数据，或部分业务的判断数据），由竞争条件或设计不当引起的薅羊毛，交易/订单信息泄露，水平越权对别人的账户查看或恶意操作，交易或业务步骤绕过，验证码绕过/失效，任意文件/备份文件下载，暴力破解。
    - 因为很多网站cookie设置不合理，静态cookie、cookie太简单、cookie永久有效等，只要攻击者收集到所有用户的用户名，就可能登录网站，获取通过XSS获取到用户的cookie，但是用户退出登录，该cookie还有效。
    - 水平越权：攻击者自己注册账号，发现通过修改数据包，就能访问不同用户的信息资料，获取通过用户的ID枚举也能获取到不同用户的信息。修改订单信息获取获取订单信息也是如此
    - 交易或业务绕过：通过抓包，修改自己订单的金额，实现低金额购买昂贵物品。防御：增加多重验证，每个订单生成hash，对比每个订单的hash，大金额订单，员工审核。
    - 验证码绕过/失效：验证码失效，前端验证码验证，直接抓包就能对用户进行暴力破解登录，或者比较验证码时弱类型，直接数组绕过验证码比较，然后就是验证码太简单，直接图像识别。通过发送手机/邮箱验证码，验证码存在response中，攻击者直接抓包即可破解。验证码存在服务器上，实现验证码加密认证。
    - 未授权访问，任意文件/备份文件的下载，管理员页面未授权访问，查看私密信息。增加验证，备份文件不能放在网站根目录下

### SSRF漏洞的成因 防御 绕过

- 成因：模拟服务器对其他服务器资源进行请求，没有做合法性验证
- 利用：构造而已内网IP做探测，或者使用其余所支持的协议对其余服务器进行攻击

    - 可以对外网、服务器所在内网，本地进行端口扫描，获取一些服务的banner信息
    - 可以运行在内网或本地的应用程序
    - 对内网web应用进行指纹识别，通过访问默认文件实现
    - 攻击内外网的web应用
    - 利用file协议读物本地文件

- 进制跳转。限制协议，内外网限制，URL限制
- 绕过：使用不同协议，针对IP，IP格式的绕过，针对URL，恶意URL增添其他字符，@之类的，301跳转+dns rebindding，十六进制

### 重用WEB开发JAVA框架

- Struts，Spring
- 常见的JAVA框架漏洞
- Struts2-045和Struts2-048。JAVA常见反序列化。045错误处理引入了ognl表达式，048封装action的过程中有一步调用getstackvalue递归获取ognl表达式，反序列化：操作对象，通过手段引入。Apache common的反射机制、readobject的重写

### 同源策略

- 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在而已文件的重要安全机制
- 源的定义：如果两个页面的协议，端口和域名都相同，则两个页面具有相同的源下表给出了相对`http://store.company.com/dir/page.html`同源检测的实例：
    - `http://store.company.com/dir2/other.html` 成果
    - `http://store.company.com/dir/inner/another.html` 成功
    - `https://store.company.com/secure.html` 失败，不同的协议
    - `http://store.company.com:81/dir/etc.html` 失败，不同的端口
    - `http://new.company.com/dir/other.html` 失败，域名不同

### DOM型和反射性XSS的区别是什么，根本区别是什么？如果针对DOM型XSS做扫描器，怎么去做，人工确认DOM型XSS，怎么去确认，给客户做XSS的时候，怎么题修补建议？

1. **DOM型和反射性的区别**

    - 反射型XSS：通过诱导用户点击，构造好的恶意payload才会触发的XSS
    - 反射型XSS的检测我们在每次请求带payload的链接时页面应该是会带有特定的畸形数据的
    - DOM型：通过修改页面的DOM节点形成的XSS
    - DOM-based： XSS由于是通过js代码进行dom操作产生的XSS，所以在请求的响应中我们甚至不一定会得到相应的畸形数据
    - 根本区别就是输出点的不同

2. **对于XSS怎么提修补建议**

    - 输出点检查：对用户输入的数据进行合法性检查，使用filter过滤敏感字符或对进行编码进行转义，针对特定类型数据进行格式检查，针对输入点的检查最好放在服务器端实现。
    - 输出点检查：对变量输出到HTML页面中时，对输出内容进行编码转义，输出在HTML中时，对其进行HTMLEncode，如果输出在Javascript脚本中时，对其进行JavascriptEncode。对使用JavaScriptEncode的变量都放在引号中并转义危险字符，data部分就无法逃逸出引号外成为code的一部分。还可以使用更加严格的方法，对所有数字字母之外的字符都使用十六进制编码，此外，要注意在浏览器中，HTML的解析会优先与Javascript的解析，编码的方式也需要考虑清楚，针对不同的输出点，我们防御XSS的方法可能会不同
    - 做HTTPOnly对cookie劫持做限制

3. **DOM型XSS 自动化测试或人工测试**

    - 人工测试思路：找到类似`document.write`、`innerHTML`赋值、`outterHTML`赋值、`window.location`操作、写`javascript:`后的内容、`eval`、`setTimeout`、`setInterval`等直接执行之类的函数点。找回其变量，回溯变量来源观察是否可控，是否经过安全函数
    - 自动化测试：不会

### CSRF中，token和referer做横向对比，谁安全等级更高？对referer的验证，。我们应该从什么角度去做？如果我们做，怎么杜绝刚才提出的问题，怎么发出空referer头的请求？针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？

1. **token和referer做横向对比，谁安全等级高？**

    - token安全等级更高，因为并不任何服务器都可以取得referer，如果从https跳到http，也不会发送referer。并且FLASH一些版本中可以自定义referer。
    - 但是token的话，要保证其足够随机且不可泄露。（不可预测性原则）

2. **对referer的验证，从事很忙角度去做？如果做，怎么杜绝问题**

    - 对header中的referer的验证，一个是空referer，一个是referer过滤或者检测不完善，为了杜绝这种问题，在验证的白名单中，正则规则应该写完善

3. **针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？**

    - 针对token的攻击，一是对它本身的攻击，重放测试一次性，分析加密规则，校验方式是否正确等，而是结合信息泄露漏洞对它信息泄露有可能是缓存、日志、get、也有可能是利用XSS
    - 很多跳转登录都依赖token，有一个跳转漏洞加反射型XSS就可以组合成登录劫持了。
    - 另外也可以结合着其他业务来描述token的安全性及设计不好怎么被绕过，比如抢红包业务之类的。

4. **如何生成一个安全的随机数**

    - 个人觉得：先利用random生成一个包含数字、字母、特殊字母的随机数，然后将产生的随机数和一个salt一起进行加密，然后转换移位等操作返回一个更长更无规律的字符串为一个随机数。

### XSS，能打到后台，但是后台系统处于内网，怎么做内网探测

- 简单的方法就是使用beef得到一个shell，然后结合msf使用

### 宽字节注入产生的原理以及根本原因

1. **产生的原理**

    - 在数据库使用了宽字符集而WEB中没有考虑这个问题的情况下，在WEN层，由于0XBF27是两个字符，在PHP中比如`addslash`和`magic_quotes_gpc`开启时，由于会对`0x27`单引号进行转义，因此`0xBF27`会变成`0xBF5C27`，而数据进入数据库中时，由于`0xBF5C`是一个另外的字符，因此`\`转义字符会被前面的`BF`吃掉，单引号因此逃逸出来可以闭合语句

2. **根本原因**

    - character_set_client(客户端的字符集)和character_set_connection(连接层的字符集)不同,或转换函数如，iconv、mb_convert_encoding使用不当。

3. **解决办法**

    - 统一数据库、web应用、操作系统所使用的字符集，避免解析产生差异，最好都设置成`utf-8`
    - 对数据进行正确的转义，如：`mysql_real_escape_string+mysql_set_charset`的使用

### SQL注入中，盲注是什么？怎么盲注？

- 盲注是在SQL注入攻击过程中，服务器关闭了错误回显，我们单纯的通过服务器返回的内容变化来判断是否存在SQL注入和利用的方式。盲注的手段有两种，一个是通过页面的返回内容是否正确（boolean-based），一种是通过SQL语句处理的时间的不同来判断是否存在注入（time-based），在这里，可以用`benchmark`，`sleep`等造成延时效果的函数

### XSS蠕虫的产生条件

- 正常情况下，一个产生XSS的页面不属于self页面，用户之间产生交互行为的页面，都可能造成XSS worm的产生，不一定需要存储型XSS

### SSL握手过程

- 建立TCP连接、客户端发送SSL请求，服务端处处理SSL请求、客户端发送公共密钥加密过的随机数据，服务端用私有密钥解密解密后的随机数据并协商暗号、服务端跟客户端利用暗号生成加密算法跟密钥key，之后正常通信。
